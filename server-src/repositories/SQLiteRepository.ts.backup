import sqlite3 from 'sqlite3';
import { CalendarEvent } from '../types/Calendar.js';

// Database row interfaces for proper typing
interface DatabaseEventRow {
  id: string;
  title: string;
  date: string;
  time: string;
  description?: string;
  location?: string;
  organizer?: string;
  attendees?: string;
  categories?: string;
  priority?: number;
  status?: string;
  visibility?: string;
  dtend?: string;
  duration?: string;
  rrule?: string;
  created?: string;
  last_modified?: string;
  sequence?: number;
  url?: string;
  geo_lat?: number;
  geo_lon?: number;
  transparency?: string;
  attachments?: string;
  timezone?: string;
  is_vacation?: number;
  caldav_filename?: string;
  calendar_path?: string;
  calendar_name?: string;
  sync_status?: string;
  local_modified?: string;
  caldav_etag?: string;
}

interface EventMetadata {
  caldav_etag?: string;
  custom_data?: Record<string, unknown>;
}

export class SQLiteRepository {
  private db!: sqlite3.Database;
  private initPromise: Promise<void>;

  constructor(dbPath: string = './calendar.db') {
    this.initPromise = new Promise((resolve, reject) => {
      this.db = new sqlite3.Database(dbPath, err => {
        if (err) {
          console.error('Failed to connect to SQLite database:', err);
          reject(err);
          return;
        }
        // Initialize database after connection is established
        this.initializeDatabase().then(resolve).catch(reject);
      });
    });
  }

  private initializeDatabase(): Promise<void> {
    return new Promise((resolve, reject) => {
      const createTableSQL = `
      CREATE TABLE IF NOT EXISTS events (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        date TEXT NOT NULL,
        time TEXT NOT NULL,
        description TEXT,
        location TEXT,
        organizer TEXT,
        attendees TEXT,
        categories TEXT,
        priority INTEGER,
        status TEXT,
        visibility TEXT,
        dtend TEXT,
        duration TEXT,
        rrule TEXT,
        created TEXT,
        last_modified TEXT,
        sequence INTEGER,
        url TEXT,
        geo_lat REAL,
        geo_lon REAL,
        transparency TEXT,
        attachments TEXT,
        timezone TEXT,
        synced_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        caldav_etag TEXT,
        caldav_filename TEXT,
        calendar_path TEXT,
        calendar_name TEXT,
        sync_status TEXT DEFAULT 'synced',
        local_modified DATETIME,
        is_vacation BOOLEAN DEFAULT 0
      )
    `;

      const createDeletedTableSQL = `
      CREATE TABLE IF NOT EXISTS deleted_events (
        id TEXT PRIMARY KEY,
        deleted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        synced_to_caldav BOOLEAN DEFAULT 0
      )
    `;

      const createVacationBalancesTableSQL = `
      CREATE TABLE IF NOT EXISTS vacation_balances (
        user_name TEXT PRIMARY KEY,
        balance_hours REAL NOT NULL DEFAULT 40.0,
        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `;

      let completedTasks = 0;
      const totalTasks = 3; // events table + deleted_events table + vacation_balances table

      const checkCompletion = () => {
        completedTasks++;
        if (completedTasks === totalTasks) {
          resolve();
        }
      };

      this.db.run(createTableSQL, err => {
        if (err) {
          console.error('Failed to create events table:', err);
          reject(err);
          return;
        }

        // Create indexes after table is confirmed to exist
        this.db.run(
          `CREATE INDEX IF NOT EXISTS idx_events_date ON events(date)`,
          err => {
            if (err) console.error('Failed to create date index:', err);
          }
        );

        this.db.run(
          `CREATE INDEX IF NOT EXISTS idx_events_sync ON events(synced_at)`,
          err => {
            if (err) console.error('Failed to create sync index:', err);
          }
        );

        checkCompletion();
      });

      this.db.run(createDeletedTableSQL, err => {
        if (err) {
          console.error('Failed to create deleted_events table:', err);
          reject(err);
          return;
        }
        checkCompletion();
      });

      this.db.run(createVacationBalancesTableSQL, err => {
        if (err) {
          console.error('Failed to create vacation_balances table:', err);
          reject(err);
          return;
        }

        // Initialize default balances for James and Morgan
        this.db.run(
          `INSERT OR IGNORE INTO vacation_balances (user_name, balance_hours) VALUES (?, ?)`,
          ['james', 40.0],
          err => {
            if (err)
              console.error(
                'Failed to initialize James vacation balance:',
                err
              );
          }
        );

        this.db.run(
          `INSERT OR IGNORE INTO vacation_balances (user_name, balance_hours) VALUES (?, ?)`,
          ['morgan', 40.0],
          err => {
            if (err)
              console.error(
                'Failed to initialize Morgan vacation balance:',
                err
              );
          }
        );

        checkCompletion();
      });
    });
  }

  /**
   * Wait for database initialization to complete
   */
  async ready(): Promise<void> {
    return this.initPromise;
  }

  /**
   * Save events with smart sync - filters out locally deleted events AND handles CalDAV deletions
   */
  async saveEventsWithSmartSync(events: CalendarEvent[]): Promise<void> {
    return new Promise(async resolve => {
      // Get current event IDs from CalDAV
      const caldavEventIds = new Set(events.map(e => e.id));

      // Find events in local database that are missing from CalDAV
      const localEvents = await this.getAllEventIds();
      const missingFromCalDAV = localEvents.filter(
        id => !caldavEventIds.has(id)
      );

      // Track CalDAV deletions (iPhone deletions)
      for (const eventId of missingFromCalDAV) {
        const isAlreadyDeleted = await this.isEventDeleted(eventId);
        if (!isAlreadyDeleted) {
          await this.trackRemoteDeletion(eventId);
        }
      }

      if (events.length === 0) {
        resolve();
        return;
      }

      // Filter out events that were deleted locally
      const filteredEvents: CalendarEvent[] = [];
      for (const event of events) {
        const isDeleted = await this.isEventDeleted(event.id);
        if (!isDeleted) {
          filteredEvents.push(event);
        } else {
        }
      }

      if (filteredEvents.length === 0) {
        resolve();
        return;
      }

      // Save the filtered events with metadata preservation
      await this.saveEvents(filteredEvents, true);
      resolve();
    });
  }

  /**
   * Get all event IDs from the events table
   */
  async getAllEventIds(): Promise<string[]> {
    return new Promise(resolve => {
      this.db.all(
        'SELECT id FROM events',
        [],
        (err, rows: DatabaseEventRow[]) => {
          if (err) {
            console.error('Error getting event IDs:', err);
            resolve([]);
          } else {
            resolve(rows.map(row => row.id));
          }
        }
      );
    });
  }

  /**
   * Track a remote deletion (iPhone deletion) - delete from events and track in deleted_events
   */
  async trackRemoteDeletion(eventId: string): Promise<void> {
    return new Promise(resolve => {
      this.db.serialize(() => {
        this.db.run('BEGIN TRANSACTION');

        // Delete the event from events table
        this.db.run('DELETE FROM events WHERE id = ?', [eventId], err => {
          if (err) {
            console.error('Error deleting event during remote deletion:', err);
            this.db.run('ROLLBACK');
            resolve();
            return;
          }
        });

        // Track in deleted_events as already synced (since it came from CalDAV)
        this.db.run(
          'INSERT OR REPLACE INTO deleted_events (id, deleted_at, synced_to_caldav) VALUES (?, CURRENT_TIMESTAMP, 1)',
          [eventId],
          err => {
            if (err) {
              console.error('Error tracking remote deletion:', err);
              this.db.run('ROLLBACK');
            } else {
              this.db.run('COMMIT');
            }
            resolve();
          }
        );
      });
    });
  }

  async saveEvents(
    events: CalendarEvent[],
    preserveMetadata: boolean = false
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      if (events.length === 0) {
        resolve();
        return;
      }

      // Choose SQL based on whether to preserve metadata
      const sql = preserveMetadata
        ? `
        INSERT INTO events (
          id, title, date, time, description, location, organizer,
          attendees, categories, priority, status, visibility, dtend,
          duration, rrule, created, last_modified, sequence, url,
          geo_lat, geo_lon, transparency, attachments, timezone, caldav_filename, calendar_path, calendar_name, sync_status, local_modified, synced_at, is_vacation
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, COALESCE((SELECT synced_at FROM events WHERE id = ?), CURRENT_TIMESTAMP), ?)
        ON CONFLICT(id) DO UPDATE SET
          title = excluded.title,
          date = excluded.date,
          time = excluded.time,
          description = excluded.description,
          location = excluded.location,
          organizer = excluded.organizer,
          attendees = excluded.attendees,
          categories = excluded.categories,
          priority = excluded.priority,
          status = excluded.status,
          visibility = excluded.visibility,
          dtend = excluded.dtend,
          duration = excluded.duration,
          rrule = excluded.rrule,
          created = excluded.created,
          last_modified = excluded.last_modified,
          sequence = excluded.sequence,
          url = excluded.url,
          geo_lat = excluded.geo_lat,
          geo_lon = excluded.geo_lon,
          transparency = excluded.transparency,
          attachments = excluded.attachments,
          timezone = excluded.timezone
          -- Note: synced_at, caldav_etag, and is_vacation are preserved during CalDAV sync
      `
        : `
        INSERT OR REPLACE INTO events (
          id, title, date, time, description, location, organizer,
          attendees, categories, priority, status, visibility, dtend,
          duration, rrule, created, last_modified, sequence, url,
          geo_lat, geo_lon, transparency, attachments, timezone, caldav_filename, calendar_path, calendar_name, sync_status, local_modified, synced_at, is_vacation
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?)
      `;

      // Handle empty events array
      if (events.length === 0) {
        resolve();
        return;
      }

      const stmt = this.db.prepare(sql);

      this.db.serialize(() => {
        this.db.run('BEGIN TRANSACTION', err => {
          if (err) {
            console.error('Failed to start transaction:', err);
            reject(err);
            return;
          }

          let hasError = false;
          let processedCount = 0;

          events.forEach(event => {
            const params = [
              event.id,
              event.title,
              event.date,
              event.time,
              event.description,
              event.location,
              event.organizer,
              JSON.stringify(event.attendees || []),
              JSON.stringify(event.categories || []),
              event.priority,
              event.status,
              event.visibility,
              event.dtend,
              event.duration,
              event.rrule,
              event.created,
              event.lastModified,
              event.sequence,
              event.url,
              event.geo?.lat,
              event.geo?.lon,
              event.transparency,
              JSON.stringify(event.attachments || []),
              event.timezone,
              (event.caldav_filename as string) || null, // Add caldav_filename
              ((event as any).calendar_path as string) || null, // Add calendar_path
              ((event as any).calendar_name as string) || null, // Add calendar_name
              ((event as any).sync_status as string) || 'synced', // Add sync_status
              ((event as any).local_modified as string) || null, // Add local_modified
            ];

            // Add is_vacation parameter for both SQL cases
            params.push(event.isVacation ? 1 : 0);

            // Add extra parameter for preserveMetadata case
            if (preserveMetadata) {
              params.push(event.id); // For COALESCE query
            }

            stmt.run(params, err => {
              if (err) {
                console.error(`Failed to save event ${event.id}:`, err);
                hasError = true;
              }

              processedCount++;

              if (processedCount === events.length) {
                if (hasError) {
                  this.db.run('ROLLBACK', rollbackErr => {
                    if (rollbackErr) {
                      console.error(
                        'Failed to rollback transaction:',
                        rollbackErr
                      );
                    }
                    reject(new Error('Transaction failed and was rolled back'));
                  });
                } else {
                  this.db.run('COMMIT', commitErr => {
                    if (commitErr) {
                      console.error('Failed to commit transaction:', commitErr);
                      this.db.run('ROLLBACK');
                      reject(commitErr);
                    } else {
                      resolve();
                    }
                  });
                }
              }
            });
          });

          stmt.finalize(err => {
            if (err) {
              console.error('Failed to finalize statement:', err);
            }
          });
        }); // Close BEGIN TRANSACTION callback
      }); // Close db.serialize
    }); // Close Promise
  } // Close function

  async getEvents(
    startDate?: Date,
    endDate?: Date,
    calendar?: string
  ): Promise<CalendarEvent[]> {
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM events';
      const params: (string | number | null)[] = [];
      const whereConditions: string[] = [];

      if (startDate && endDate) {
        whereConditions.push('date >= ? AND date <= ?');
        params.push(startDate.toISOString(), endDate.toISOString());
      } else if (startDate) {
        whereConditions.push('date >= ?');
        params.push(startDate.toISOString());
      } else if (endDate) {
        whereConditions.push('date <= ?');
        params.push(endDate.toISOString());
      }

      if (calendar) {
        whereConditions.push('calendar_name = ?');
        params.push(calendar);
      }

      if (whereConditions.length > 0) {
        query += ' WHERE ' + whereConditions.join(' AND ');
      }

      query += ' ORDER BY date ASC';

      this.db.all(query, params, (err, rows: DatabaseEventRow[]) => {
        if (err) {
          reject(err);
          return;
        }

        const events = rows.map(this.rowToEvent);
        resolve(events);
      });
    });
  }

  async getLastSyncTime(): Promise<Date | null> {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT MAX(synced_at) as last_sync FROM events',
        (err, row: DatabaseEventRow) => {
          if (err) reject(err);
          else resolve(row?.last_sync ? new Date(row.last_sync) : null);
        }
      );
    });
  }

  async clearOldEvents(olderThan: Date): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM events WHERE synced_at < ?',
        [olderThan.toISOString()],
        err => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }

  private rowToEvent(row: DatabaseEventRow): CalendarEvent {
    const event: CalendarEvent = {
      id: row.id,
      title: row.title,
      date: row.date,
      time: row.time,
    };

    if (row.description) event.description = row.description;
    if (row.location) event.location = row.location;
    if (row.organizer) event.organizer = row.organizer;
    if (row.attendees) event.attendees = JSON.parse(row.attendees);
    if (row.categories) event.categories = JSON.parse(row.categories);
    if (row.priority) event.priority = row.priority;
    if (row.status) event.status = row.status;
    if (row.visibility) event.visibility = row.visibility;
    if (row.dtend) event.dtend = row.dtend;
    if (row.duration) event.duration = row.duration;
    if (row.rrule) event.rrule = row.rrule;
    if (row.created) event.created = row.created;
    if (row.last_modified) event.lastModified = row.last_modified;
    if (row.sequence) event.sequence = row.sequence;
    if (row.url) event.url = row.url;
    if (row.geo_lat && row.geo_lon)
      event.geo = { lat: row.geo_lat, lon: row.geo_lon };
    if (row.transparency) event.transparency = row.transparency;
    if (row.attachments) event.attachments = JSON.parse(row.attachments);
    if (row.timezone) event.timezone = row.timezone;
    if (row.is_vacation !== undefined)
      event.isVacation = Boolean(row.is_vacation);

    return event;
  }

  async updateEventMetadata(
    eventId: string,
    metadata: EventMetadata
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const updateParts: string[] = [];
      const params: (string | number | null)[] = [];

      if (metadata.caldav_etag !== undefined) {
        updateParts.push('caldav_etag = ?');
        params.push(metadata.caldav_etag);
      }

      if (metadata.custom_data !== undefined) {
        // Could add custom_data column in future
      }

      if (updateParts.length === 0) {
        resolve();
        return;
      }

      params.push(eventId);
      const sql = `UPDATE events SET ${updateParts.join(', ')} WHERE id = ?`;

      this.db.run(sql, params, err => {
        if (err) {
          console.error(`Failed to update metadata for event ${eventId}:`, err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  /**
   * Delete an event from the database and track it as deleted
   */
  async deleteEvent(eventId: string): Promise<boolean> {
    return new Promise(resolve => {
      this.db.serialize(() => {
        // Start transaction
        this.db.run('BEGIN TRANSACTION');

        // Delete the event
        this.db.run('DELETE FROM events WHERE id = ?', [eventId], err => {
          if (err) {
            console.error('Error deleting event:', err);
            this.db.run('ROLLBACK');
            resolve(false);
            return;
          }
        });

        // Track the deletion
        this.db.run(
          'INSERT OR REPLACE INTO deleted_events (id, deleted_at, synced_to_caldav) VALUES (?, CURRENT_TIMESTAMP, 0)',
          [eventId],
          err => {
            if (err) {
              console.error('Error tracking deleted event:', err);
              this.db.run('ROLLBACK');
              resolve(false);
            } else {
              this.db.run('COMMIT');
              resolve(true);
            }
          }
        );
      });
    });
  }

  /**
   * Check if an event was deleted locally
   */
  async isEventDeleted(eventId: string): Promise<boolean> {
    return new Promise(resolve => {
      this.db.get(
        'SELECT id FROM deleted_events WHERE id = ?',
        [eventId],
        (err, row) => {
          if (err) {
            console.error('Error checking deleted event:', err);
            resolve(false);
          } else {
            resolve(!!row);
          }
        }
      );
    });
  }

  /**
   * Get all deleted event IDs that need to sync to CalDAV
   */
  async getDeletedEventsToSync(): Promise<string[]> {
    return new Promise(resolve => {
      this.db.all(
        'SELECT id FROM deleted_events WHERE synced_to_caldav = 0',
        [],
        (err, rows: DatabaseEventRow[]) => {
          if (err) {
            console.error('Error getting deleted events:', err);
            resolve([]);
          } else {
            resolve(rows.map(row => row.id));
          }
        }
      );
    });
  }

  /**
   * Mark a deleted event as synced to CalDAV
   */
  async markDeletedEventSynced(eventId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE deleted_events SET synced_to_caldav = 1 WHERE id = ?',
        [eventId],
        err => {
          if (err) {
            console.error('Error marking deleted event as synced:', err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  /**
   * Clean up old deleted event records (older than 30 days)
   */
  async cleanupDeletedEvents(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        "DELETE FROM deleted_events WHERE deleted_at < datetime('now', '-30 days') AND synced_to_caldav = 1",
        [],
        err => {
          if (err) {
            console.error('Error cleaning up deleted events:', err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  close(): void {
    this.db.close(err => {
      if (err) {
        console.error('Error closing SQLite database:', err);
      } else {
      }
    });
  }

  /**
   * Get events that need to be synced to CalDAV
   */
  async getPendingEvents(): Promise<CalendarEvent[]> {
    return new Promise((resolve, reject) => {
      this.db.all(
        "SELECT * FROM events WHERE sync_status = 'pending' ORDER BY local_modified ASC",
        [],
        (err, rows: DatabaseEventRow[]) => {
          if (err) {
            reject(err);
            return;
          }
          const events = rows.map(this.rowToEvent);
          resolve(events);
        }
      );
    });
  }

  /**
   * Mark an event as synced to CalDAV
   */
  async markEventSynced(eventId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        "UPDATE events SET sync_status = 'synced' WHERE id = ?",
        [eventId],
        err => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }

  /**
   * Get calendar statistics
   */
  async getCalendarStats(): Promise<Array<{ name: string; count: number }>> {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT calendar_name as name, COUNT(*) as count FROM events WHERE calendar_name IS NOT NULL GROUP BY calendar_name ORDER BY count DESC',
        [],
        (err, rows: DatabaseEventRow[]) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(rows);
        }
      );
    });
  }

  /**
   * Get events with metadata for a specific calendar
   */
  async getEventsWithMetadata(calendar?: string): Promise<
    Array<
      CalendarEvent & {
        calendar_path?: string;
        calendar_name?: string;
        caldav_filename?: string;
      }
    >
  > {
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM events';
      const params: (string | number | null)[] = [];

      if (calendar) {
        query += ' WHERE calendar_name = ?';
        params.push(calendar);
      }

      query += ' ORDER BY date ASC';

      this.db.all(query, params, (err, rows: DatabaseEventRow[]) => {
        if (err) {
          reject(err);
          return;
        }

        const events = rows.map(row => ({
          ...this.rowToEvent(row),
          calendar_path: row.calendar_path,
          calendar_name: row.calendar_name,
          caldav_filename: row.caldav_filename,
        }));
        resolve(events);
      });
    });
  }

  /**
   * VACATION TRACKING METHODS
   * Modular data access methods for vacation balance management
   */

  /**
   * Get vacation balances for all users
   */
  async getVacationBalances(): Promise<
    Array<{ user_name: string; balance_hours: number; last_updated: string }>
  > {
    await this.ready();
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT user_name, balance_hours, last_updated FROM vacation_balances',
        (err, rows: DatabaseEventRow[]) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(rows);
        }
      );
    });
  }

  /**
   * Update vacation balance for a specific user
   */
  async updateVacationBalance(
    userName: string,
    newBalance: number
  ): Promise<void> {
    await this.ready();
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE vacation_balances SET balance_hours = ?, last_updated = CURRENT_TIMESTAMP WHERE user_name = ?',
        [newBalance, userName],
        err => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }

  /**
   * Get vacation balance for a specific user
   */
  async getVacationBalance(userName: string): Promise<number> {
    await this.ready();
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT balance_hours FROM vacation_balances WHERE user_name = ?',
        [userName],
        (err, row: DatabaseEventRow) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(row ? row.balance_hours : 0);
        }
      );
    });
  }
}
